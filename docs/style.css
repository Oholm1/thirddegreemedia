/*
  Trail Variants for Third Degree Media
  -------------------------------------
  Modes: "rainbow", "comet", "sparks", "minimal"

  HOW TO USE
  1) Include this file after anime.js (or without it; we have a fallback):
     <script nonce="r4nd0m" defer src="/js/trail-variants.js"></script>
  2) Choose a mode by either:
     - Adding data-trail="rainbow|comet|sparks|minimal" to <body>
     - Or setting: window.TRAIL_MODE = "rainbow" before this script runs
  3) Optional: Toggle modes at runtime with `window.setTrailMode('comet')`.

  CSP: Replace the example nonce in your HTML with your real per-request nonce.
  Accessibility: Respects prefers-reduced-motion; auto-disables on low-power devices.
*/

(() => {
  const supportsReduced = matchMedia('(prefers-reduced-motion: reduce)').matches;
  if (supportsReduced) return; // Respect user preference

  const MODE = (window.TRAIL_MODE || document.body.getAttribute('data-trail') || 'rainbow').toLowerCase();

  // Basic pool to avoid constant DOM thrash
  const POOL_SIZE = 120;
  const pool = [];
  let poolIndex = 0;

  function makeParticle(className = 'trail') {
    const el = document.createElement('div');
    el.className = className;
    el.style.position = 'fixed';
    el.style.width = '12px';
    el.style.height = '12px';
    el.style.borderRadius = '50%';
    el.style.pointerEvents = 'none';
    el.style.zIndex = '9999';
    el.style.transform = 'translate(-50%, -50%)';
    el.style.willChange = 'transform, opacity';
    el.style.opacity = '0';
    document.body.appendChild(el);
    return el;
  }

  for (let i = 0; i < POOL_SIZE; i++) pool.push(makeParticle('trail'));

  // Shared helpers
  const hasAnime = () => typeof window.anime === 'function';
  const clamp = (n, min, max) => Math.max(min, Math.min(max, n));
  const rand = (min, max) => Math.random() * (max - min) + min;

  // Color utilities
  const golden = 0.61803398875;
  let hue = Math.floor(rand(0, 360));
  function nextHue(step = golden * 360) {
    hue = (hue + step) % 360; return hue;
  }

  // Engines
  function animate(el, opts) {
    if (hasAnime()) {
      window.anime({
        targets: el,
        opacity: [opts.opacityFrom ?? 1, 0],
        translateX: opts.tx ?? 0,
        translateY: opts.ty ?? 0,
        scale: [opts.scaleFrom ?? 1, opts.scaleTo ?? 2],
        duration: opts.duration ?? 600,
        easing: opts.easing || 'easeOutExpo',
        complete: () => { el.style.opacity = '0'; }
      });
    } else {
      // Fallback CSS transition
      el.style.transition = 'opacity 0.6s ease-out, transform 0.6s ease-out';
      requestAnimationFrame(() => {
        el.style.opacity = '0';
        el.style.transform += ' scale(2)';
      });
      setTimeout(() => { el.style.opacity = '0'; }, 650);
    }
  }

  function nextParticle() {
    const el = pool[poolIndex++ % POOL_SIZE];
    el.style.opacity = '1';
    return el;
  }

  // Modes
  const modes = {
    rainbow(e) {
      const el = nextParticle();
      const h = nextHue();
      el.style.background = `hsl(${h} 100% 60%)`;
      el.style.boxShadow = '0 0 12px hsla(0,0%,100%,.15)';
      el.style.left = e.clientX + 'px';
      el.style.top = e.clientY + 'px';
      animate(el, { duration: 520, scaleTo: 2.2 });
    },

    comet(e) {
      const tailLen = 6;
      let vx = (e.movementX || 0);
      let vy = (e.movementY || 0);
      const speed = clamp(Math.hypot(vx, vy), 2, 40);
      for (let i = 0; i < tailLen; i++) {
        const el = nextParticle();
        const fade = 1 - i / tailLen;
        const size = 10 + (i * 2);
        el.style.width = size + 'px';
        el.style.height = size + 'px';
        el.style.background = '#00ffcc';
        el.style.filter = 'blur(' + (i * 0.6) + 'px)';
        el.style.left = e.clientX - vx * i * 0.6 + 'px';
        el.style.top = e.clientY - vy * i * 0.6 + 'px';
        animate(el, { duration: 450 + i * 25, scaleTo: 1.6 + i * 0.1, opacityFrom: fade });
      }
    },

    sparks(e) {
      const count = 10;
      for (let i = 0; i < count; i++) {
        const el = nextParticle();
        const angle = rand(0, Math.PI * 2);
        const dist = rand(10, 40);
        const tx = Math.cos(angle) * dist;
        const ty = Math.sin(angle) * dist;
        const h = (hue + i * 18) % 360;
        el.style.background = `hsl(${h} 100% 60%)`;
        el.style.left = e.clientX + 'px';
        el.style.top = e.clientY + 'px';
        animate(el, { tx, ty, duration: 520 + i * 8, scaleTo: 1.2 });
      }
    },

    minimal(e) {
      const el = nextParticle();
      el.style.background = 'currentColor';
      el.style.opacity = '0.9';
      el.style.left = e.clientX + 'px';
      el.style.top = e.clientY + 'px';
      animate(el, { duration: 320, scaleTo: 1.3 });
    }
  };

  // Dispatcher with throttling using rAF
  let pending = false; let lastEvent = null;
  function onMove(e) {
    lastEvent = e; if (pending) return; pending = true;
    requestAnimationFrame(() => {
      (modes[MODE] || modes.rainbow)(lastEvent);
      pending = false;
    });
  }

  // Click burst for any mode
  function onClick(e) {
    for (let i = 0; i < 12; i++) modes.sparks(e);
  }

  // Touch support
  function onTouch(e) {
    const t = e.touches[0]; if (!t) return;
    const proxy = { clientX: t.clientX, clientY: t.clientY, movementX: 0, movementY: 0 };
    onMove(proxy);
  }

  // Public API
  window.setTrailMode = function setTrailMode(mode) {
    document.body.setAttribute('data-trail', mode);
    window.TRAIL_MODE = mode;
  };

  // Attach listeners
  window.addEventListener('mousemove', onMove, { passive: true });
  window.addEventListener('touchmove', onTouch, { passive: true });
  window.addEventListener('click', onClick, { passive: true });
})();


